### 1. C++内存泄露相关

内存泄漏主要指的是堆上的动态内存泄露

堆内存是操作系统划归给堆管理器（操作系统中的一段代码，属于操作系统的内存管理单元）来管理的，堆管理器提供了对应的接口_sbrk、_mmap等，其中调用哪个接口取决于设定的阈值，需要较小内存使用sbrk，并且sbrk申请的内存在delete之后不会立即返还给系统，反之使用mmap。

##### 堆与栈的区别

- 空间大小不同：一般来讲在 32 位系统下，堆内存可以达到3G的空间，几乎没限制，栈有一定的空间大小
- 能否产生碎片不同：堆有碎片、栈的内存连续
- 增长方向不同：堆向着内存地址增加的方向，栈向着内存地址减小的方向
- 分配方式不同：
  - 堆都是动态分配的，比如我们常见的malloc/new；而栈则有静态分配和动态分配两种
  - 静态分配是编译器完成的，比如局部变量的分配，而栈的动态分配则通过alloca()函数完成
  - 栈的动态分配的内存由编译器进行释放，而堆上的动态分配的内存则必须由开发人自行释放
- 分配效率不同：栈有操作系统分配专门的寄存器存放栈的地址，堆内存的申请和释放专门有运行时库提供的函数

##### 内存泄漏的产生方式

- 常发性内存泄漏：在每次执行的时候，都会产生内存泄漏。
- 偶发性内存泄漏：只在特定的场景下才会被执行
- 一次性内存泄漏：造成泄漏的代码只会被执行一次
- 隐式内存泄漏：

##### 内存泄露的类别

- 未释放：在函数结束时，内存一定要用delete/free进行释放，在编写析构函数的时候，一定要仔细分析成员变量有没有申请动态内存，如果有，则需要手动释放
- 未匹配：
- 虚析构：为了避免因为继承导致的内存泄漏，也就是没有成功调用子类的析构函数，我们需要将父类的析构函数声明为`virtual`

```c
派生类对象在创建时构造函数调用顺序:
1. 调用父类的构造函数
2. 调用父类成员变量的构造函数
3. 调用派生类本身的构造函数
派生类对象在析构时的析构函数调用顺序:
1. 执行派生类自身的析构函数
2. 执行派生类成员变量的析构函数
3. 执行父类的析构函数
```

​	==遵守一条规则：无论派生类有没有申请堆上的资源，请将父类的析构函数声明为virtual==

- 循环引用：由shared_ptr循环引用导致的，可以利用weak_ptr来消除

##### 如何避免内存泄漏

- 避免在堆上分配
- 记得手动释放内存
- 避免使用裸指针
- 使用STL或自己实现对象
- 利用智能指针
  - unique_ptr：`独享管理权`。当unique_ptr对象被销毁时，会在其析构函数内删除关联的原始指针。
  - shared_ptr：`共享管理权`。
  - weak_ptr：主要是为了解决shared_ptr的`循环引用`

- RAII`(Resource Acquisition is Initialization(资源获取即初始化))`：RAII的做法是使用一个对象，在其构造时获取对应的资源，在对象生命周期内控制对资源的访问，使之始终保持有效，最后在对象析构的时候，释放构造时获取的资源。

##### 通过日志系统定位问题



##### *参考*

https://bbs.huaweicloud.com/blogs/351858





---

### 2. 智能指针（主要用于动态内存）

##### shared_ptr类

- 需要采用直接初始化形式

- `share_ptr`允许多个指针指向同一个对象，它的析构函数会递减它指向的对象的引用计数，当引用计数变为0，`shared_ptr`的析构函数会销毁对象并释放它的内存
- **空悬指针**：指向一块曾经保存数据对象但现在已经无效的内存的指针。

​	解决空悬指针的方法：在指针即将离开其作用域之前释放掉它所关联的内存。

- 智能指针与普通指针：

​	不能将一个普通指针隐式地转换为一个智能指针，可以显式地用`int *`创建`shared_ptr<int>`,例如说`return shared_ptr<int>(new int(p))`;

​	默认情况下，一个用来初始化智能指针的普通指针必须指向一个动态内存；	

​	不要混合使用普通指针和智能指针；

​	如果使用智能指针管理的资源不是new分配的资源，需要传递给它一个删除器。

##### unique_ptr类

- 需要采用直接初始化形式
- 不支持普通的拷贝和赋值，但可以拷贝和赋值一个即将被销毁的`unique_ptr`

##### weak_ptr类

- 不控制指向对象的生存期，指向由`shared_ptr`管理的对象

- 用于解决`shared_ptr`相互引用时的死锁问题,如果说两个`shared_ptr`相互引用,那么这两个指针的引用计数永远不可能下降为0,资源永远不会释放。

- 不能通过`weak_ptr`直接访问对象,需要先将其转化为`shared_ptr`





---

### 3. 深拷贝与浅拷贝

当出现类的等号赋值时，就会调用拷贝函数

##### 区别

1. 在未定义显示拷贝构造函数的情况下，系统会调用默认的拷贝函数——即浅拷贝，它能够完成成员的一一复制。当数据成员中没有指针时，浅拷贝是可行的；但当数据成员中有指针时，如果采用简单的浅拷贝，则两类中的两个指针将指向同一个地址，当对象快结束时，会调用两次析构函数，而导致指针悬挂现象，所以，此时，必须采用深拷贝。

2. ==深拷贝与浅拷贝的区别就在于深拷贝会在堆内存中另外申请空间来储存数据，从而也就解决了指针悬挂的问题。简而言之，当数据成员中有指针时，必须要用深拷贝。==



- 浅拷贝的操作下，当a和b中的某指针指向同一内存区域，若a析构时将其指针指向的动态分配的内存释放了一次后，b析构时再次将被释放过的内存释放。该结果是未定义的，可能导致内存泄漏或程序崩溃





---

### 4. C++虚函数实现

##### 虚函数的调用过程

- 当调用一个虚函数时，首先通过对象内存中的vptr找到虚函数表vtbl，接着通过vtbl找到对应虚函数的实现区域并进行调用。其中**被执行的代码必须和调用函数的对象的动态类型相一致**。
- 当一个类声明或继承了虚函数，这个类就有了自己的vtbl（每个类只有一个）。vtbl数组中的每一个元素对应一个函数指针指向该类的一个虚函数，同时该类的每一个对象都会包含一个vptr，vptr指向该vtbl的地址。
  - 一般继承时，子类的虚函数表中先将父类虚函数放在前，再放自己的虚函数指针。
  - 如果子类覆盖了父类的虚函数，将被放到了虚表中**原来父类虚函数**的位置。
  - 在多继承的情况下，**每个父类都有自己的虚表，子类的成员函数被放到了第一个父类的表中。**，也就是说当类在多重继承中时，其实例对象的内存结构并不只记录一个虚函数表指针。基类中有几个存在虚函数，则子类就会保存几个虚函数表指针。（这样来看开销可能就比较大）
- **调用过程**
  - 通过对象的 vptr 找到类的 vtbl。这个代价只是一个偏移调整(以得到 vptr)和一个指针的间接寻址(以得到 vtbl)。
  - 找到对应 vtbl 内的指向被调用函数的指针。这步的代价只是在 vtbl 数组内的一个偏移。
  - 调用第二步找到的的指针所指向的函数。
    - 在单继承的情况下：调用虚函数所需的代价基本上和非虚函数效率一样，在大多数计算机上它多执行了很少的一些指令，所以有很多人一概而论说虚函数性能不行是不太科学的。
    - 在多继承的情况下：由于会根据多个父类生成多个vptr，在对象里为寻找 vptr 而进行的偏移量计算会变得复杂一些，但这些并不是虚函数的性能瓶颈。虚函数运行时所需的代价主要是虚函数不能是内联函数。这也是非常好理解的，是因为内联函数是指在编译期间用被调用的函数体本身来代替函数调用的指令，但是虚函数的“虚”是指“直到运行时才能知道要调用的是哪一个函数。”但虚函数的运行时多态特性就是要在运行时才知道具体调用哪个虚函数，所以没法在编译时进行内联函数展开。当然如果通过对象直接调用虚函数它是可以被内联，但是大多数虚函数是通过对象的指针或引用被调用的，这种调用不能被内联。 因为这种调用是标准的调用方式，所以虚函数实际上不能被内联。
- 空间占用
  - 次要代价：**编译器会给每一个包含虚函数或继承了虚函数的类自动建立一个虚函数表**，所以虚函数的一个代价就是会增加类的体积。在虚函数接口较少的类中这个代价并不明显，虚函数表vtbl的体积相当于几个函数指针的体积，如果你有大量的类或者在每个类中有大量的虚函数,你会发现 vtbl 会占用大量的地址空间。
  - **主要代价**：主要的代价是发生在类的继承过程中，在上面的分析中，可以看到，当子类继承父类的虚函数时，子类会有自己的vtbl，如果子类只覆盖父类的一两个虚函数接口，子类vtbl的其余部分内容会与父类重复。如果存在大量的子类继承，且重写父类的虚函数接口只占总数的一小部分的情况下，会造成大量地址空间浪费。

##### 虚函数的应用注意事项

- 内联函数（inline）

  虚函数用于实现运行时的多态，或者称为晚绑定或动态绑定。而内联函数用于提高效率。内联函数的原理是，在编译期间，对调用内联函数的地方的代码替换成函数代码。内联函数对于程序中需要频繁使用和调用的小函数非常有用。默认地，类中定义的所有函数，除了虚函数之外，会隐式地或自动地当成内联函数(注意：内联只是对于编译器的一个建议，编译器可以自己决定是否进行内联).
  无论何时，使用基类指针或引用来调用虚函数，它都不能为内联函数(因为调用发生在运行时)。但是，无论何时，使用类的对象(不是指针或引用)来调用时，可以当做是内联，因为编译器在编译时确切知道对象是哪个类的。

- 静态成员函数（static）

  static成员不属于任何类对象或类实例，所以即使给此函数加上virutal也是没有任何意义的。此外静态与非静态成员函数之间有一个主要的区别，那就是静态成员函数没有this指针，从而导致两者调用方式不同。虚函数依靠vptr和vtable来处理。vptr是一个指针，在类的构造函数中创建生成，并且只能用this指针来访问它，因为它是类的一个成员，并且vptr指向保存虚函数地址的vtable。虚函数的调用关系：this -> vptr -> vtable ->virtual function，对于静态成员函数，它没有this指针，所以无法访问vptr. 这就是为何static函数不能为virtual。

- 构造函数和析构函数（constructor and desconstructor）

  虚函数基于虚表vtable（内存空间），构造函数 (constructor) 如果是virtual的，调用时也需要根据vtable寻找，但是constructor是virtual的情况下是找不到的，因为constructor自己本身都不存在了，创建不到class的实例，没有实例class的成员（除了public static/protected static for friend class/functions，其余无论是否virtual）都不能被访问了。此外构造函数不仅不能是虚函数。而且在构造函数中调用虚函数，实际执行的是父类的对应函数，因为自己还没有构造好,多态是被disable的。

  **对于可能作为基类的类的析构函数要求就是virtual的**。因为如果不是virtual的，派生类析构的时候调用的是基类的析构函数，而基类的析构函数只要对基类部分进行析构，从而可能导致派生类部分出现内存泄漏问题。

- 纯虚函数

  析构函数可以是纯虚的，但**纯虚析构函数必须有定义体**，因为析构函数的调用是在子类中隐含的。

##### *参考*

https://jacktang816.github.io/post/virtualfunction/





---

### 5. C++静态库和动态库

##### 为什么有了静态库还需要动态库

- 静态库产生空间浪费
- 静态库如果更新了，使用它的所有应用程序都需要重新编译、发布给用户

​	静态库在链接阶段，会将汇编生成的目标文件.o与引用到的库一起链接打包到可执行文件中。因此对应的链接方式称为静态链接。

​	动态库在程序编译时并不会被连接到目标代码中，而是在程序运行时才被载入。

​	不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例，规避了空间浪费问题。动态库也被称为共享库。





##### *参考*

[C++静态库与动态库](https://www.cnblogs.com/skynet/p/3372855.html)

[静态库链接动态库时，如何使用该静态库](https://blog.csdn.net/newchenxf/article/details/51735600)

---



### 6. C++指针和引用的区别

1. 指针是存储变量地址的变量，引用是变量别名
2. 指针在定义时不必初始化，引用在定义是需要初始化，不然会报错
3. 引用只有在定义时初始化一次，之后不能改变；指针变量的值可以改变
4. 指针可以有多级，引用只有一级
5. sizeof（指针）得到的是本指针的大小，sizeof（引用）得到的是引用所指向变量的大小
6. 当把指针作为参数进行传递时，也是将实参的一个拷贝传递给形参，两者指向的地址相同，但不是同一个变量，在函数中改变这个变量的指向不影响实参，而引用却可以。

##### 在传递函数参数时，什么时候使用指针？什么时候使用引用

- 需要返回函数内局部变量的内存的时候用指针。使用指针传参需要开辟内存，用完要记得释放指针，不然会内存泄漏。而返回局部变量的引用是没有意义的
- 对栈空间大小比较敏感（比如递归）的时候使用引用。使用引用传递不需要创建临时变量，开销要更小
- 类对象作为参数传递的时候使用引用，这是C++类对象传递的标准方式



---



### 7. malloc和new

##### malloc和new的区别

- malloc和free是标准库函数，支持覆盖；new和delete是运算符，支持重载。
- malloc仅仅分配内存空间，free仅仅回收空间，不具备调用构造函数和析构函数功能，用malloc分配空间存储类的对象存在风险；new和delete除了分配回收功能外，还会调用构造函数和析构函数。
- malloc和free返回的是void类型指针（必须进行类型转换），new和delete返回的是具体类型指针。

##### 既然有了malloc/free，为什么还要new/delete

- malloc/free和new/delete都是用来申请内存和回收内存的。
- 在对非基本数据类型的对象使用的时候，对象创建的时候还需要执行构造函数，销毁的时候要执行析构函数。而malloc/free是库函数，是已经编译的代码，所以不能把构造函数和析构函数的功能强加给malloc/free，所以new/delete是必不可少的。



---



### 8. C++中struct和class的区别

相同点：

- 两者都有成员函数、公有和私有部分
- 任何可以用class完成的工作，同样可以用struct完成

不同点：

- 两者中如果未指定成员公私有，struct默认共有，class默认私有
- strut默认public继承，class默认private继承

引申：

- C中：struct是用户自定义数据类型；

  C++中：struct是抽象数据类型，支持成员函数的定义（C++中struct能继承，能够实现多态）

- C中：struct没有权限设置，且struct智能是一些变量的集合体，可封装函数不能隐藏函数，且成员不可以是函数

  C++中：struct增加了访问权限，且和类一样可以有成员函数，成员默认访问说明符为public（为了和C兼容）

- struct作为类的一种特例是用来自定义数据结构的。一个结构标记声明后，在C中必须在结构标记前加上struct，才能做结构类型名（除：typedef struct  class{};）;C++中结构体标记（结构体名）可以直接作为结构体类型名使用，此外结构体struct在C++中被当作类的一种特例



---



### 9. C++中const和static的作用

##### static

- 不考虑类的情况

  - 隐藏。所有不加static的全局变量和函数具有全局可见性，可以在其他文件中使用，加了之后只能在该文件所在的编译模块中使用

  - 默认初始化为0，包括未初始化的全局静态变量与局部静态变量，都存在全局未初始化区
  - 静态变量在函数内定义，始终存在，且只进行一次初始化，具有记忆性，其作用范围与局部变量相同，函数退出后仍然存在，但不能使用

- 考虑类的情况

  - static成员变量：只与类关联，不与类的对象关联。定义时要分配空间，不能在类声明中初始化，必须在类定义体外部初始化，初始化时不需要标示为static；可以被非static成员函数任意访问。
  - static成员函数：不具有this指针，无法访问类对象的非static成员变量和非static成员函数；**不能被声明为const、虚函数和volatile**；可以被非static成员函数任意访问

##### const

- 不考虑类的情况
  - const常量在定义时必须初始化，之后无法更改
  - const形参可以接收const和非const类型的实参，例如// i 可以是 int 型或者 const int 型void fun(const int& i){	//...}
- 考虑类的情况
  - const成员变量：不能在类定义外部初始化，只能通过构造函数初始化列表进行初始化，并且必须有构造函数；不同类对其const数据成员的值可以不同，所以不能在类中声明时初始化
  - const成员函数：const对象不可以调用非const成员函数；非const对象都可以调用；不可以改变非mutable（用该关键字声明的变量可以在const成员函数中被修改）数据的值



---



### 10. static的作用

1.  **隐藏**：当同时编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性。

2.  **保持变量内容的持久**：（static变量中的记忆功能和全局生存期）存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。共有两种变量存储在静态存储区：全局变量和static变量，只不过和全局变量比起来，static可以控制变量的可见范围，说到底static还是用来隐藏的。

3.  **static变量默认初始化为0**

4. **类成员变量被声明为static**：

   - 函数体内static变量的作用范围为该函数体，不同于auto变量，该变量的内存只被分配一次，因此其值在下次调用时仍维持上次的值；
   - 在模块内的static全局变量可以被模块内所有函数访问，但不能被模块外其它函数访问；
   - 在模块内的static函数只可被这一模块内的其它函数调用，这个函数的使用范围被限制在声明它的模块内；
   - 在类中的static成员变量属于整个类所拥有，对类的所有对象只有一份拷贝；
   - 在类中的static成员函数属于整个类所拥有，这个函数不接收this指针，因而只能访问类的static成员变量。

   类内：

   - static类对象必须要在类外进行初始化，static修饰的变量先于对象存在，所以static修饰的变量要在类外初始化；

   - 由于static修饰的类成员属于类，不属于对象，因此static类成员函数是没有this指针的，this指针是指向本对象的指针。正因为没有this指针，所以static类成员函数不能访问非static的类成员，只能访问 static修饰的类成员；

   - static成员函数不能被virtual修饰，static成员不属于任何对象或实例，所以加上virtual没有任何实际意义；静态成员函数没有this指针，虚函数的实现是为每一个对象分配一个vptr指针，而vptr是通过this指针调用的，所以不能为virtual；虚函数的调用关系，this->vptr->ctable->virtual function
