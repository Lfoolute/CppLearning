### 判断子序列
给定字符串 s 和 t ，判断 s 是否为 t 的子序列
- 状态转移方程
```cpp
if (s[i - 1] == t[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1;
else dp[i][j] = dp[i][j - 1];
```
[392判断子序列](392.cc)

### 不同的子序列
给定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数
- 状态转移方程
```cpp
if (s[i - 1] == t[j - 1]) {
    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];
} else {
    dp[i][j] = dp[i - 1][j];
}
```
[115不同的子序列](115.cc)

### 两个字符串的删除
给定两个单词 word1 和 word2，找到使得 word1 和 word2 相同所需的最小步数，每步可以删除任意一个字符串中的一个字符
- 状态转移方程
```cpp
if (word1[i - 1] == word2[j - 1]) {
    dp[i][j] = dp[i - 1][j - 1];
} else {
    dp[i][j] = min({dp[i - 1][j - 1] + 2, dp[i - 1][j] + 1, dp[i][j - 1] + 1});
}
```
[583两个字符串的删除](583.cc)

### 编辑距离
将 word1 转换成 word2 所使用的最少操作数 
**几种情况**
1. `if (word1[i - 1] == word2[j - 1]) `
   + 不操作
2. `if (word1[i - 1] != word2[j - 1]) `
   + 增
   + 删
   + 换

状态转移方程：
```cpp
if (word1[i - 1] == word2[j - 1]) {
    dp[i][j] = dp[i - 1][j - 1];
}
else {
    dp[i][j] = min({dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]}) + 1;
}
```
[72编辑距离](72.cc)